---
title: Architecture
description: Comprendre l'architecture hexagonale de Foundation Builder
---

# Architecture hexagonale

Foundation Builder suit les principes de l'architecture hexagonale (Clean Architecture / Ports & Adapters) pour sÃ©parer clairement la logique mÃ©tier des dÃ©tails techniques.

## ğŸ—ï¸ Principe fondamental

L'architecture hexagonale organise le code en couches concentriques, oÃ¹ la logique mÃ©tier est au centre et les dÃ©tails techniques sont Ã  la pÃ©riphÃ©rie.

## ğŸ“ Structure des dossiers

```
src/
â”œâ”€â”€ core/                    # CÅ“ur de l'application
â”‚   â”œâ”€â”€ models/             # EntitÃ©s mÃ©tier
â”‚   â”œâ”€â”€ services/           # Cas d'usage et logique mÃ©tier
â”‚   â””â”€â”€ ports/              # Interfaces de contrat
â”‚       â”œâ”€â”€ in/             # Ports entrants (interfaces)
â”‚       â””â”€â”€ out/            # Ports sortants (interfaces)
â”œâ”€â”€ repositories/           # ImplÃ©mentations des ports sortants
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ di-container/       # Injection de dÃ©pendances
â””â”€â”€ app/                    # Couche d'adaptation (Next.js)
```

## ğŸ”„ Flux de donnÃ©es

### Ports entrants (Inbound Ports)

Les ports entrants dÃ©finissent les contrats pour les cas d'usage de l'application :

```typescript
// src/core/ports/in/auth.port.ts
export interface AuthPort {
  signIn(email: string, password: string): Promise<AuthResult>;
  signUp(email: string, password: string): Promise<AuthResult>;
  signOut(): Promise<void>;
}
```

### Ports sortants (Outbound Ports)

Les ports sortants dÃ©finissent les contrats pour les dÃ©pendances externes :

```typescript
// src/core/ports/out/auth.repository.ts
export interface AuthRepository {
  createUser(user: User): Promise<User>;
  findUserByEmail(email: string): Promise<User | null>;
  updateUser(user: User): Promise<User>;
}
```

### Services (Use Cases)

Les services implÃ©mentent la logique mÃ©tier en utilisant les ports :

```typescript
// src/core/services/auth.service.ts
export class AuthService implements AuthPort {
  constructor(private authRepository: AuthRepository) {}

  async signIn(email: string, password: string): Promise<AuthResult> {
    // Logique mÃ©tier pour la connexion
  }
}
```

## ğŸ¯ Avantages

### SÃ©paration des responsabilitÃ©s

- **Logique mÃ©tier** : IndÃ©pendante des frameworks et technologies
- **Infrastructure** : Peut Ãªtre changÃ©e sans impacter le mÃ©tier
- **Tests** : Facilite les tests unitaires et d'intÃ©gration

### Ã‰volutivitÃ©

- Ajout de nouvelles fonctionnalitÃ©s sans casser l'existant
- Remplacement des dÃ©pendances externes
- Support de multiples interfaces (web, mobile, API)

### MaintenabilitÃ©

- Code organisÃ© et prÃ©visible
- RÃ©duction du couplage entre les couches
- FacilitÃ© de comprÃ©hension pour les nouveaux dÃ©veloppeurs

## ğŸ”§ Injection de dÃ©pendances

Foundation Builder utilise l'injection de dÃ©pendances pour inverser le contrÃ´le :

```typescript
// src/lib/di-container/di-container.ts
export const container = {
  authService: () => new AuthService(container.authRepository()),
  authRepository: () => new FirebaseAuthRepository(),
};
```

## ğŸ“‹ RÃ¨gles de codage

- **Principe de responsabilitÃ© unique** : Chaque classe a une seule responsabilitÃ©
- **Return early** : Ã‰viter les imbrications avec des retours prÃ©coces
- **ImmutabilitÃ©** : Utiliser des donnÃ©es immuables
- **Gestion d'erreurs explicite** : GÃ©rer tous les cas d'erreur
- **Types stricts** : Utiliser TypeScript de maniÃ¨re stricte
- **Composition** : PrÃ©fÃ©rer la composition Ã  l'hÃ©ritage
