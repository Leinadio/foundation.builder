---
title: Architecture
description: Comprendre l'architecture hexagonale de Foundation Builder
---

# Architecture hexagonale

Foundation Builder suit les principes de l'architecture hexagonale (Clean Architecture / Ports & Adapters) pour séparer clairement la logique métier des détails techniques.

## 🏗️ Principe fondamental

L'architecture hexagonale organise le code en couches concentriques, où la logique métier est au centre et les détails techniques sont à la périphérie.

## 📁 Structure des dossiers

```
src/
├── core/                    # Cœur de l'application
│   ├── models/             # Entités métier
│   ├── services/           # Cas d'usage et logique métier
│   └── ports/              # Interfaces de contrat
│       ├── in/             # Ports entrants (interfaces)
│       └── out/            # Ports sortants (interfaces)
├── repositories/           # Implémentations des ports sortants
├── lib/
│   └── di-container/       # Injection de dépendances
└── app/                    # Couche d'adaptation (Next.js)
```

## 🔄 Flux de données

### Ports entrants (Inbound Ports)

Les ports entrants définissent les contrats pour les cas d'usage de l'application :

```typescript
// src/core/ports/in/auth.port.ts
export interface AuthPort {
  signIn(email: string, password: string): Promise<AuthResult>;
  signUp(email: string, password: string): Promise<AuthResult>;
  signOut(): Promise<void>;
}
```

### Ports sortants (Outbound Ports)

Les ports sortants définissent les contrats pour les dépendances externes :

```typescript
// src/core/ports/out/auth.repository.ts
export interface AuthRepository {
  createUser(user: User): Promise<User>;
  findUserByEmail(email: string): Promise<User | null>;
  updateUser(user: User): Promise<User>;
}
```

### Services (Use Cases)

Les services implémentent la logique métier en utilisant les ports :

```typescript
// src/core/services/auth.service.ts
export class AuthService implements AuthPort {
  constructor(private authRepository: AuthRepository) {}

  async signIn(email: string, password: string): Promise<AuthResult> {
    // Logique métier pour la connexion
  }
}
```

## 🎯 Avantages

### Séparation des responsabilités

- **Logique métier** : Indépendante des frameworks et technologies
- **Infrastructure** : Peut être changée sans impacter le métier
- **Tests** : Facilite les tests unitaires et d'intégration

### Évolutivité

- Ajout de nouvelles fonctionnalités sans casser l'existant
- Remplacement des dépendances externes
- Support de multiples interfaces (web, mobile, API)

### Maintenabilité

- Code organisé et prévisible
- Réduction du couplage entre les couches
- Facilité de compréhension pour les nouveaux développeurs

## 🔧 Injection de dépendances

Foundation Builder utilise l'injection de dépendances pour inverser le contrôle :

```typescript
// src/lib/di-container/di-container.ts
export const container = {
  authService: () => new AuthService(container.authRepository()),
  authRepository: () => new FirebaseAuthRepository(),
};
```

## 📋 Règles de codage

- **Principe de responsabilité unique** : Chaque classe a une seule responsabilité
- **Return early** : Éviter les imbrications avec des retours précoces
- **Immutabilité** : Utiliser des données immuables
- **Gestion d'erreurs explicite** : Gérer tous les cas d'erreur
- **Types stricts** : Utiliser TypeScript de manière stricte
- **Composition** : Préférer la composition à l'héritage
