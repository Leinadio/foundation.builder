---
title: Services et cas d'usage
description: Logique m√©tier et cas d'usage de Foundation Builder
---

# Services et cas d'usage

Foundation Builder impl√©mente une logique m√©tier robuste suivant l'architecture hexagonale, avec des services clairs et des cas d'usage bien d√©finis.

## üèóÔ∏è Architecture des services

### Structure des services

```
src/core/
‚îú‚îÄ‚îÄ services/           # Cas d'usage et logique m√©tier
‚îÇ   ‚îú‚îÄ‚îÄ auth.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ user.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ email.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ payment.service.ts
‚îú‚îÄ‚îÄ ports/             # Interfaces de contrat
‚îÇ   ‚îú‚îÄ‚îÄ in/            # Ports entrants
‚îÇ   ‚îî‚îÄ‚îÄ out/           # Ports sortants
‚îî‚îÄ‚îÄ models/            # Entit√©s m√©tier
    ‚îú‚îÄ‚îÄ user.ts
    ‚îú‚îÄ‚îÄ session.ts
    ‚îî‚îÄ‚îÄ payment.ts
```

## üîê Service d'authentification

### AuthService

G√®re l'authentification des utilisateurs avec support multi-provider.

```typescript
// src/core/services/auth.service.ts
export class AuthService implements AuthPort {
  constructor(private authRepository: AuthRepository, private emailService: EmailService) {}

  async signIn(email: string, password: string): Promise<AuthResult> {
    // Validation des donn√©es
    if (!this.isValidEmail(email)) {
      throw new ValidationError("Email invalide");
    }

    // Authentification
    const user = await this.authRepository.findUserByEmail(email);
    if (!user || !(await this.verifyPassword(password, user.passwordHash))) {
      throw new AuthenticationError("Identifiants invalides");
    }

    // Cr√©ation de la session
    const session = await this.createSession(user);

    return {
      user: this.mapUserToDTO(user),
      session,
      token: this.generateToken(session),
    };
  }

  async signUp(email: string, password: string, userData: UserData): Promise<AuthResult> {
    // Validation
    await this.validateSignUpData(email, password, userData);

    // V√©rification de l'unicit√©
    const existingUser = await this.authRepository.findUserByEmail(email);
    if (existingUser) {
      throw new ConflictError("Utilisateur d√©j√† existant");
    }

    // Cr√©ation de l'utilisateur
    const user = await this.createUser(email, password, userData);

    // Envoi de l'email de confirmation
    await this.emailService.sendWelcomeEmail(user.email, user.name);

    return this.signIn(email, password);
  }
}
```

### Cas d'usage d'authentification

- **Connexion** : Email/mot de passe, Google, GitHub
- **Inscription** : Validation, v√©rification d'unicit√©
- **D√©connexion** : Nettoyage des sessions
- **R√©cup√©ration de mot de passe** : Email de r√©initialisation
- **V√©rification d'email** : Confirmation d'adresse email

## üë§ Service d'utilisateur

### UserService

G√®re les donn√©es et pr√©f√©rences des utilisateurs.

```typescript
// src/core/services/user.service.ts
export class UserService implements UserPort {
  constructor(private userRepository: UserRepository) {}

  async updateProfile(userId: string, profileData: ProfileData): Promise<User> {
    // Validation des donn√©es
    this.validateProfileData(profileData);

    // R√©cup√©ration de l'utilisateur
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError("Utilisateur non trouv√©");
    }

    // Mise √† jour
    const updatedUser = { ...user, ...profileData };
    return await this.userRepository.update(updatedUser);
  }

  async deleteAccount(userId: string): Promise<void> {
    // V√©rification de l'utilisateur
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError("Utilisateur non trouv√©");
    }

    // Suppression des donn√©es associ√©es
    await this.userRepository.deleteAllUserData(userId);

    // Suppression de l'utilisateur
    await this.userRepository.delete(userId);
  }
}
```

### Cas d'usage utilisateur

- **Profil** : Mise √† jour des informations personnelles
- **Pr√©f√©rences** : Configuration des param√®tres
- **Suppression de compte** : Suppression compl√®te des donn√©es
- **Historique** : Gestion de l'historique des actions

## üí≥ Service de paiement

### PaymentService

G√®re les paiements et abonnements avec Stripe.

```typescript
// src/core/services/payment.service.ts
export class PaymentService implements PaymentPort {
  constructor(private paymentRepository: PaymentRepository, private userRepository: UserRepository) {}

  async createPaymentIntent(userId: string, amount: number, currency: string): Promise<PaymentIntent> {
    // Validation
    if (amount <= 0) {
      throw new ValidationError("Montant invalide");
    }

    // R√©cup√©ration de l'utilisateur
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError("Utilisateur non trouv√©");
    }

    // Cr√©ation du Payment Intent
    const paymentIntent = await this.paymentRepository.createPaymentIntent({
      amount: this.convertToCents(amount),
      currency,
      customer: user.stripeCustomerId,
      metadata: { userId },
    });

    return this.mapToPaymentIntentDTO(paymentIntent);
  }

  async createSubscription(userId: string, priceId: string): Promise<Subscription> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError("Utilisateur non trouv√©");
    }

    // Cr√©ation de l'abonnement
    const subscription = await this.paymentRepository.createSubscription({
      customer: user.stripeCustomerId,
      items: [{ price: priceId }],
      metadata: { userId },
    });

    // Mise √† jour du statut utilisateur
    await this.userRepository.updateSubscriptionStatus(userId, subscription.status);

    return this.mapToSubscriptionDTO(subscription);
  }
}
```

### Cas d'usage de paiement

- **Paiement unique** : Payment Intents pour les achats ponctuels
- **Abonnements** : Gestion des abonnements r√©currents
- **Webhooks** : Traitement des √©v√©nements Stripe
- **Remboursements** : Gestion des remboursements
- **Facturation** : G√©n√©ration des factures

## üìß Service d'email

### EmailService

G√®re l'envoi d'emails transactionnels.

```typescript
// src/core/services/email.service.ts
export class EmailService implements EmailPort {
  constructor(private emailRepository: EmailRepository) {}

  async sendWelcomeEmail(email: string, name: string): Promise<void> {
    const template = await this.getEmailTemplate("welcome");
    const content = this.renderTemplate(template, { name });

    await this.emailRepository.send({
      to: email,
      subject: "Bienvenue sur Foundation Builder",
      html: content,
    });
  }

  async sendPasswordResetEmail(email: string, resetToken: string): Promise<void> {
    const resetUrl = `${process.env.APP_URL}/reset-password?token=${resetToken}`;

    await this.emailRepository.send({
      to: email,
      subject: "R√©initialisation de votre mot de passe",
      html: this.renderPasswordResetTemplate(resetUrl),
    });
  }
}
```

### Cas d'usage d'email

- **Bienvenue** : Email de confirmation d'inscription
- **R√©initialisation** : Email de r√©cup√©ration de mot de passe
- **Notifications** : Alertes et notifications importantes
- **Marketing** : Emails promotionnels (optionnel)

## üîÑ Injection de d√©pendances

### Configuration des services

```typescript
// src/lib/di-container/di-container.ts
export const container = {
  // Services
  authService: () => new AuthService(container.authRepository(), container.emailService()),
  userService: () => new UserService(container.userRepository()),
  paymentService: () => new PaymentService(container.paymentRepository(), container.userRepository()),
  emailService: () => new EmailService(container.emailRepository()),

  // Repositories
  authRepository: () => new FirebaseAuthRepository(),
  userRepository: () => new FirestoreUserRepository(),
  paymentRepository: () => new StripePaymentRepository(),
  emailRepository: () => new ResendEmailRepository(),
};
```

## üß™ Tests des services

### Tests unitaires

```typescript
// tests/services/auth.service.test.ts
describe("AuthService", () => {
  let authService: AuthService;
  let mockAuthRepository: jest.Mocked<AuthRepository>;

  beforeEach(() => {
    mockAuthRepository = createMockAuthRepository();
    authService = new AuthService(mockAuthRepository);
  });

  it("should sign in user with valid credentials", async () => {
    // Arrange
    const email = "test@example.com";
    const password = "password123";
    mockAuthRepository.findUserByEmail.mockResolvedValue(mockUser);

    // Act
    const result = await authService.signIn(email, password);

    // Assert
    expect(result.user.email).toBe(email);
    expect(mockAuthRepository.findUserByEmail).toHaveBeenCalledWith(email);
  });
});
```

## üìä Monitoring et logs

### Logging des services

```typescript
// src/core/services/base.service.ts
export abstract class BaseService {
  protected logger: Logger;

  constructor(serviceName: string) {
    this.logger = new Logger(serviceName);
  }

  protected logError(error: Error, context: any): void {
    this.logger.error(error.message, { error, context });
  }

  protected logInfo(message: string, data?: any): void {
    this.logger.info(message, data);
  }
}
```

## üöÄ Performance

### Optimisations

- **Cache** : Mise en cache des donn√©es fr√©quemment utilis√©es
- **Pagination** : Pagination des listes importantes
- **Lazy loading** : Chargement √† la demande
- **Connection pooling** : Pool de connexions pour les bases de donn√©es
